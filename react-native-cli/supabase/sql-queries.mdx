---
title: "Database Tables Setup"
description: "Set up the required database tables and policies for Launchtoday's profile and feedback features"
---

Launchtoday comes with pre-built profile and feedback screens that require specific database tables and security policies to function. This guide provides the necessary SQL setup that powers these features:

- The profiles table that drives the Profile screen, including user avatars and profile information
- The feedback table that enables the Feedback submission screen
- An avatars storage bucket for profile images
- Security policies to protect user data

```sql
-- Create a table for public profiles
create table profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  avatar_url text,
  website text,
  bio text,
  has_seen_onboarding boolean,
  full_name text,

  constraint username_length check (char_length(username) >= 3)
);

-- Set up Row Level Security (RLS)
alter table profiles
  enable row level security;

create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can insert their own profile." on profiles
  for insert with check ((select auth.uid()) = id);

create policy "Users can update own profile." on profiles
  for update using ((select auth.uid()) = id);

-- Create feedback table
create table feedback (
  id bigint primary key,
  user_id uuid references auth.users not null,
  type text,
  title text,
  description text,
  created_at timestamp with time zone
);

-- Set up Row Level Security (RLS) for feedback table
alter table feedback
  enable row level security;

-- Add policies for feedback table
create policy "Users can view their own feedback." on feedback
  for select using ((select auth.uid()) = user_id);

create policy "Users can insert their own feedback." on feedback
  for insert with check ((select auth.uid()) = user_id);

-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Set up Storage!
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

-- Set up storage policies
CREATE POLICY "allow_avatar_reads"
ON storage.objects FOR SELECT
USING (
    bucket_id = 'avatars'::text
    AND auth.role() = 'authenticated'::text
);

CREATE POLICY "allow_avatar_uploads"
ON storage.objects FOR INSERT
WITH CHECK (
    bucket_id = 'avatars'::text
    AND auth.role() = 'authenticated'::text
    AND (auth.uid())::text = (storage.foldername(name))[1]
);

CREATE POLICY "allow_avatar_updates"
ON storage.objects FOR UPDATE
USING (
    bucket_id = 'avatars'::text
    AND auth.role() = 'authenticated'::text
    AND (auth.uid())::text = (storage.foldername(name))[1]
);

CREATE POLICY "allow_avatar_deletes"
ON storage.objects FOR DELETE
USING (
    bucket_id = 'avatars'::text
    AND auth.role() = 'authenticated'::text
    AND (auth.uid())::text = (storage.foldername(name))[1]
);
```

## Understanding the queries

Let's break down each query to understand its purpose and functionality.

### Profiles Table and Policies

The profiles table and associated policies handle user profile management:

- Creates a profiles table to store user data (username, avatar, website, etc) with Row Level Security enabled
- Sets up policies to control access - public viewing allowed but updates restricted to profile owners
- Automatically creates profile records when new users sign up via OAuth

```sql
-- Create a table for public profiles
create table profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  avatar_url text,
  website text,
  bio text,
  has_seen_onboarding boolean,
  full_name text,

  constraint username_length check (char_length(username) >= 3)
);

-- Set up Row Level Security (RLS)
alter table profiles
  enable row level security;

create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can insert their own profile." on profiles
  for insert with check ((select auth.uid()) = id);

create policy "Users can update own profile." on profiles
  for update using ((select auth.uid()) = id);

-- Automatic profile creation
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
```

### Feedback Table and Policies

The feedback table and associated policies handle user feedback management:

- Creates a feedback table to store user feedback (type, title, description, etc) with Row Level Security enabled
- Sets up policies to control access - viewing and updates restricted to feedback owners
- Allows authenticated users to submit and view their own feedback

```sql
create table feedback (
  id bigint primary key,
  user_id uuid references auth.users not null,
  type text,
  title text,
  description text,
  created_at timestamp with time zone
);

-- Set up Row Level Security (RLS) for feedback table
alter table feedback
  enable row level security;

-- Add policies for feedback table
create policy "Users can view their own feedback." on feedback
  for select using ((select auth.uid()) = user_id);

create policy "Users can insert their own feedback." on feedback
  for insert with check ((select auth.uid()) = user_id);
```

### Avatar Storage Setup

The avatars bucket and associated policies handle profile image management:

- Creates an avatars storage bucket to store user profile pictures
- Sets up policies to control access - authenticated users can read all avatars
- Restricts uploads, updates and deletes to the avatar owner's folder

```sql
-- Set up Storage!
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

-- Set up storage policies
CREATE POLICY "allow_avatar_reads"
ON storage.objects FOR SELECT
USING (
    bucket_id = 'avatars'::text
    AND auth.role() = 'authenticated'::text
);

CREATE POLICY "allow_avatar_uploads"
ON storage.objects FOR INSERT
WITH CHECK (
    bucket_id = 'avatars'::text
    AND auth.role() = 'authenticated'::text
    AND (auth.uid())::text = (storage.foldername(name))[1]
);

CREATE POLICY "allow_avatar_updates"
ON storage.objects FOR UPDATE
USING (
    bucket_id = 'avatars'::text
    AND auth.role() = 'authenticated'::text
    AND (auth.uid())::text = (storage.foldername(name))[1]
);

CREATE POLICY "allow_avatar_deletes"
ON storage.objects FOR DELETE
USING (
    bucket_id = 'avatars'::text
    AND auth.role() = 'authenticated'::text
    AND (auth.uid())::text = (storage.foldername(name))[1]
);
```

## Setting Up Your Database

You'll need to run these SQL queries in your Supabase project to enable these features. Navigate to the SQL editor in your Supabase project and paste the script above.

1. Open your Supabase project's SQL editor
2. Copy and paste the complete setup script first
3. Test the setup by:

   - Creating a new user (should auto-create profile)
   - Submitting feedback
   - Uploading a profile picture

   <img
     src="/images/supabase-queries.jpg"
     alt="OAuth Credentials"
     style={{
       borderRadius: "10px",
       maxHeight: "450px",
     }}
   />

Once completed, your Launchtoday app will have working profile, feedback, and avatar management features.
